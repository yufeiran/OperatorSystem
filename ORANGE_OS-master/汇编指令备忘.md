## 第四章 寄存器与第一个程序
1. 8086CPU的工作过程:   
    (1)从CS:IP指向的内存单元读取指令,读取的指令进入指令缓冲器;   
    (2)IP=IP+所读指令的长度,从而指向下一条指令;   
    (3)执行指令.转到步骤(1),重复这个过程.
    
2. 修改CS,IP的指令:   
    (1) jmp  段基址 : 偏移地址  :同时修改 CS, IP 的值   
    (2) jmp  偏移地址   :只修改 IP 的值   
    
3. DS : 存放数据段基地址, [ N ] 表示N偏移量的内存地址中存放的数据,   
            8086CPU自动取ds中的数据作为内存单元的段基址

4. 段寄存器SS存放栈的段基址,SP存放栈顶的偏移地址,任意时刻,SS:SP指向栈顶元素.

5. 指令 push ax 执行步骤: SP=SP -one  2 , SS : SP执行当前栈顶前面的内存单元粗; 将ax 的值送进去   

6. pop ax 执行步骤 : 将SS:SP指向的内存单元中的数据送入ax中, SP=SP+2, SS:SP指向新栈顶 

7. pop 操作时,内存中的数据还在,8086CPU也不会检查栈的越界问题.

8. 一个程序从写出到执行的过程:   
    (1)编写程序 (2)对源程序进行编译链接产生可执行文件,(包括程序机器码和描述信息) 
    (3)操作系统根据可执行文件中的描述信息,将可执行文件的机器码和数据加载入内存,初始化,执行.
    
9. 汇编伪指令:由编译器来执行的指令,编译器根据伪指令来进行相关的编译工作.   
    segment , ends 的功能是定义一个段   
    assume  假设和关联   
    标号   标识了一个地址
    end 程序指明在何处结束
```
            assume  cs: codesg      #假设cs的值是codesg的地址
            codesg   segment
        s:                                        #标号,代表此处的地址
            add ax,bx

            mov ax,4c00H                #程序返回
            int 21H  
            
            codesg   ends
            end
```
## 第五章 
1. [...] 描述的是一个内存单元的内容  
    (idata)描述的是地址为idata的内存单元的内容   
    (寄存器)描述的是寄存器的内容
    
2. 指令loop 标号 ,执行过程:(1) (cx)=(cx)-1;  (2) 判断(cx)是否为0,不为0则跳至标号处执行,0则向下执行.   

3. 数据不能以字母开头,譬如要表示ffffH,需用 0ffffH来表示,在前面加多一个0   

4. dw 定义数据,开辟内存   1个字   db: 1个字节        dd: 2个字   
    dup 和db,dw,dd是配合使用的, 用来进行数据的重复,比如   
     db 300 dup (0) ;                  #300个字节   都是0   
     db 3 dup ('abc','ABC')         #18个字节,'abcABCabcABCabcABC'

5. and指令:按位与运算      or指令:按位或运算   

6. 大小写转换: 就ASCII码的二进制形式来看,除第5位外,大写字母和小写字母的其他各位都一样
    指令: mov  al,[bx]        ,and al,11011111B     mov [bx], al  #转化为大写字母,并写回
    
7. + **AX，BX，CX，DX 称作为数据寄存器：** 
    AX (Accumulator)：累加寄存器，也称之为累加器； BX (Base)：基地址寄存器；CX (Count)：计数器寄存器；DX (Data)：数据寄存器；      
    + **SP 和 BP 又称作为指针寄存器：**SP (Stack Pointer)：堆栈指针寄存器；BP (Base Pointer)：基指针寄存器；   
    + **SI 和 DI 又称作为变址寄存器：**SI (Source Index)：源变址寄存器；DI (Destination Index)：目的变址寄存器；   
    + **控制寄存器：IP (Instruction Pointer)：**指令指针寄存器；FLAG：标志寄存器；  
    + **段寄存器：CS (Code Segment)：**代码段寄存器；DS (Data Segment)：数据段寄存器；SS (Stack Segment)：堆栈段寄存器；ES (Extra Segment)：附加段寄存器；
  
8. (1)8086CPU的内存单元寻址[...]中,只能出现的寄存器是bx, si, di, bp   
    (2)在[...]中,这四个寄存器可以单独出现,或者只能以4种组合出现: bx和si, bx和di, bp和si, bp和di   
    (3)只要在[...]中使用寄存器bp,段基地址默认在SS中
    
9. 指令处理数据的长度: (1)通过寄存器来指明,  (2)通过操作符,word ptr , byte ptr   

10. div 除法指令:   
    (1)除数:在reg或内存单元中,有8位和16位   
    (2)被除数: 默认放在AX 或 AX和DX中,  DX存放高16位, AX存放低16位   
    (3)结果: 若除数是8位,则AL存放商,AH存放余数;    若除数是16位,AX商, DX余数   
 
## 第九章 转移指令
1. offset指令,用于计算标号到段基址的偏移量   例: mov ax , offset 标号

2. jmp short ptr 标号 : 8位近转移   
    jmp nert ptr 标号 : 16位近转移   
    jmp far ptr 标号: 段间远转移 CS=标号所在段基址  , IP=标号的偏移量   
    转移地址在内存中:   
    jmp word ptr 内存单元地址(段内):    从内存单元地址处存放一个字,是转移的目的偏移地址   
    例: mov ax,0123H  ; mov ds:[0],ax   ;  jmp word ptr ds:[0]   (IP=0123H)   
    jmp dword ptr 内存单元地址(段间转移) : (CS)=(内存单元地址+2),(IP)=(内存单元地址)   
    
3. jcxz 条件短转移,当(CX)==0时跳转到标号处,修改范围:-128~127   
    
4. 80 * 25 彩色字符模式显示缓冲区的结构:    
    + 内存地址空间从 0B8000H ~ 0BFFFFH 共32KB的空间,向这个空间写入数据,将立即被显示           
    + 要显示的每个字符占两个字节,分别存放ASCII字符和属性    
    + 高位字节的8位属性值意义分别如下: 闪烁, (背景色)红绿蓝, 高亮, (前景色)红绿蓝   
    
5. **ret指令**: 用栈中的数据修改IP,实现近转移   
    步骤:  从栈SS:SP中, pop IP   
    **retf指令**: 用栈SS:SP中的数据,修改CS,IP的内容,从而实现远转移   
    步骤: POP IP,  POP  CS
    
6. **CALL指令**: 将当前的IP 或 CS,IP压入栈中;  转移   
    (1)call 标号: 相当于: push IP , jmp near ptr 标号   
    (2)call far ptr 标号: 相当于push CS , push IP , jmp far ptr 标号   
    (3)call 16 位reg , 相当于 push IP, jmp 16位reg   
    (4)call word ptr 内存单元地址 ,相当于: push  IP, jmp word ptr 内存单元地址   
    (5)call dword ptr 内存单元地址, 相当于: push CS , push IP , jmp dword ptr 内存单元地址   
    
7. **MUL指令: 乘法运算**: mul  reg , mul 内存单元   
    (1) mul  byte ptr ds:[0] : 8位运算 ,相当于 (ax) = (al) * ((ds) * 16 + 0 )    
    (2) mul word ptr [bx + si + 8 ] :相当于:    
        结果 = (ax) * ((ds) * 16 + (bx) + (si) + 8 )   
        (ax) = 结果的低16位   (dx) = 结果的高16位   

8. 第十章: 暂时不看   

9. 标志寄存器:   
    ZF : 零位标志,zf=1 说明结果为0   
    PF : 奇偶标志, 如果1的个数为偶数, pf =1 ; 如果为奇数, pf = 0
    SF : 符号标志位, 结果为负, sf = 1 ; 结果为正  ,SF= 0   
    CF : 进位标志位, **无符号数**相加时记录了 进位 , 两个数据相减时 , 记录了借位   
    OF : 溢出标志位, **有符号数**运算的结果, 如果溢出, OF=1 , 如果没有, OF = 0   
    
10. 指令 adc ax , bx: 相当于: (ax) = (ax) + (bx) + CF ,加上上一条指令的进位   
       可以利用这条指令来进行加法的第二步运算, adc 和 add 配合可以实现对更大数据的运算  
       
 11. Sbb 指令, 带借位减法指令   
 
 12. ** CMP指令**: 比较指令, 相当于减法指令,只是不保存结果, 但是影响标志寄存器   
 
 13. 条件转移指令:    
    jcxz : 如果 (cx) == 0 , 则转移   
    还有: je, jne , jb, jnb, ja, jna等   
    
14. **DF标志位和串传送指令**   
    df = 0 : 每次操作后 si , di 递增   
    df = 1 : 每次操作后, si , di 递减   
    指令**movsb** :( es : di ) = ( ds : si)   ; si ++  , di ++ 或 si --  , di --   
    指令**movsw** : 将 ds : si 指向的字送入 es : di ,然后si, di 根据df 加2 或 减 2   
    指令: rep  movsb 或 rep movsw : rep 的作用: 根据cx 的值, 重复执行后面的串操作指令   
    cld 指令 : 将标志寄存器的df 位置为 0   
    std 指令 : 将标志寄存器的df 位置为 1   
    
15. pushf 和 popf : 将标志寄存器的值压栈 , 从栈中弹出标志寄存器的值

## 第十一章 内中断
1. CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址,可以把中断类型码作为中断向量表的表项号,定位相应的表项.8086PC机,中断向量表指定放在地址0处,从0000:0000~0000:03FF之间共1024个单元,每个表项占2个字,高地址放段基址,低地址放偏移量   

2. **iret**指令: 相当于: POP IP ; POP  CS ; POPF :使CPU回到执行中断前的CPU现场   

3. 安装,就是把程序代码写到某个合适的位置

4. int n 指令,相当于引发一个N号中断的中断过程:    常和IRET指令搭配使用   
    取中断类型码N; 标志寄存器入栈,IF=0, TF=0; CS,IP入栈;(IP)=(n*4),(CS)=(n*4+2)
    
5. DOS的启动:   
    (1)开机加电,初始化(CS)=0FFFFH,(IP)=0,跳到BIOS硬件执行系统检测和初始化程序;   
    (2)初始化:将BIOS提供的中断例程入口地址登记在中断向量表中;   
    (3) int 19h ,进行系统的引导   
    
6. 端口:各种接口芯片中,都有一组可以有CPU读写的寄存器,称为端口; CPU对他们进行统一编址,形成了一个统一的端口地址空间.

7. 端口的读写指令:    注意:端口的读写只能使用ax 或 al 来存放中转的数据
    in al,60h ; 从60h端口读入一个字节   
    out 20h,al ; 往20h端口写入一个字节

8. 逻辑左移指令 : shl :将一个数据向左移位;将最后移出的一位写入CF中;最低位用0补充   
    逻辑右移指令:  shr :与shl相反,最后一位移出的存入CF中,   
    **注意** : 若移动的位数大于1,需要将其放入CL中, 如: mov al , 44H, mov cl , 3 ; shr al , CL
    
9. 标志寄存器的** IF **位:当CPU检测到可屏蔽中断信息时,如果IF=1,则CPU在执行完当前指令后响应中断,引发中断过程;如果IF=0,则不响应可屏蔽中断, 禁止其他的可屏蔽中断.   

10.  sti , 设置IF = 1 ; cli , 设置 IF = 0   

11. 不可屏蔽中断: 在执行完当前指令 后, CPU必须立即响应, 引发中断过程.   

12. 键盘按键处理过程: 
    (1)每一个键都相当于一个开关,按下键开关打开,产生一个说明位置的扫描码,松开键的时候将扫描码送入60h端口   
    (2)引发int 9号中断:
    (3)9号中断例程: 读出60h端口,判断,如果是字符键的扫描码,送入BIOS缓冲区,如果是控制键,写入....   
    
13. 